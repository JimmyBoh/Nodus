
var support = require('./support');
var spawn = require('child_process').spawn;

var fs  = require('fs');
var Suckle = require('suckle');

exports.Minifier = Minifier;
exports.minify = function(a,b,c) {
  return new Minifier(a,b).compress(c);
};

function Minifier() {
  var args = Array.prototype.slice.call(arguments);
  var lastArg = args[args.length-1];
  var options = {};

  if (typeof(lastArg) === 'function') {
    this.callback = args.pop();
  };

  switch(args[0].constructor) {
    case Object:
      options = args.shift();
      var fileOut = options.fileOut;
      fileOut = fileOut || args.shift();
      break;
    case String:
    case Array:
      options = {
        fileIn:args.shift(),
        fileOut:args.shift()
      };
      break;
    case fs.ReadStream:
      this.stream = args.shift();
      this.stream.pause();
      options = args.shift() || {};
      break;
    default:
      throw new Error('Invalid options type');
      break;
  };

  var fileIn = options.fileIn;
  switch(fileIn.constructor) {
    case String:
      this.fileIn =  [fileIn];
      this.fileType = support.fileType(fileIn);
      break;
    case Array:
      var fileType = support.fileType(fileIn[0]);
      var uniform = fileIn.every(function(file) {
        return support.fileType(file) === fileType;
      });

      if (!uniform) {
        throw new Error('Non-uniform filetypes');
      }else {
        this.fileType = fileType;
      };

      this.fileIn = fileIn;
      break;
    default:
      throw new Error('fileIn must be String or Array');
      break;
    };

    var css = /^css$/.test(this.fileType);
    this.buffer = options.buffer || 200 * 1024;
    this.type   = options.type || (css ? 'yui' : 'uglify');
    this.fileOut = options.fileOut;
    this.encoding = options.encoding;
};

Minifier.prototype.compress = function(fn) {
  if (typeof(fn) !== 'function') {
    fn = this.callback || function(){};
  };

  var props = [
    this.options,
    this.fileType
  ];

  var command = support[this.type].apply(this, props);

  var error = null;
  var enc = this.encoding;

  var cb = function(data) {
    this.tempFile = null;
    if (enc)
      data = data.toString(enc);
    fn(error, data);
  }.bind(this); 

  var suckle = new Suckle(cb);

  if (this.fileOut) {
    var ws = fs.createWriteStream(this.fileOut);
    suckle.pipe(ws);
  };

  var args = command.args;
  var command = command.command;
  var opts = { 
    maxBuffer:this.buffer,
    stdio:'pipe' 
  };

  var compress = spawn(command, args, opts);

  var erred = function(err) {
    error = err;
    compress.kill();
  };

  compress.on('error', erred);
  compress.stdout.setEncoding('utf8');
  compress.stdout.pipe(suckle);

  var stdin = compress.stdin;
  var write = stdin.write.bind(stdin);
  var end = stdin.end.bind(stdin);

  var readFile = function(file, fn) {
    var rs = fs.createReadStream(file);
    rs.on('data', write);
    rs.on('end', fn);
    rs.on('error', erred);
  };

  if (this.stream) {
    this.stream.pipe(compress.stdin);
    this.stream.on('error', erred);
    this.stream.resume();
  } else if (this.fileIn) {
    var fileIn = this.fileIn.slice();
    ;(function next() {
      if (!fileIn.length)
        return end();
      var file = fileIn.shift();
      readFile(file, next);
    })();
  };

  return suckle;
};
